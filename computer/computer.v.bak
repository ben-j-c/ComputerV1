
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module computer(

	//////////// Audio //////////
	input 		          		AUD_ADCDAT,
	inout 		          		AUD_ADCLRCK,
	inout 		          		AUD_BCLK,
	output		          		AUD_DACDAT,
	inout 		          		AUD_DACLRCK,
	output		          		AUD_XCK,

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// I2C for Audio and Video-In //////////
	output		          		FPGA_I2C_SCLK,
	inout 		          		FPGA_I2C_SDAT,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// IR //////////
	input 		          		IRDA_RXD,
	output		          		IRDA_TXD,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// PS2 //////////
	inout 		          		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	inout 		          		PS2_DAT2,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS
);
	wire CU_ie, CU_clk, CU_ie_address, CU_debugEnable;
	wire[15:0] BUS;
	//=======================================================
	//  Ports
	//=======================================================
	
	wire[15:0] PORT_deviceData[15:0];
	wire[15:0] PORT_deviceData2[15:0];
	wire[255:0] PORT_deviceData_1D, PORT_deviceData_1D_2;
	wire[15:0] PORT_hostData;
	wire[31:0] PORT_service, PORT_DE, PORT_DRW;
	wire[4:0] PORT_select;
	wire PORT_HE, PORT_HRW, PORT_EN;
	
	
	genvar i;
	generate
		for(i = 0 ; i < 16 ; i = i + 1) begin: _2d_array_to_1d_array
			assign PORT_deviceData_1D[(i+1)*16 - 1:i*16] = PORT_deviceData[i];
			assign PORT_deviceData_1D_2[(i+1)*16 - 1:i*16] = PORT_deviceData2[i];
		end
	endgenerate
	
	ports #(16,16) primaryPorts(CLOCK_50, !PORT_select[4], PORT_HE, PORT_DE, PORT_HRW, PORT_DRW, PORT_select[3:0], PORT_hostData, PORT_deviceData_1D, PORT_service[15:0]);
	ports #(16,16) secondaryPorts(CLOCK_50, PORT_select[4], PORT_HE, PORT_DE[31:16], PORT_HRW, PORT_DRW[31:16], PORT_select[3:0], PORT_hostData, PORT_deviceData_1D_2, PORT_service[31:16]);
	
	assign PORT_deviceData[7] = BUS;
	assign PORT_DE[7] = 1;
	assign PORT_DRW[7] = 1;
	
	sw_input 		PORT_SW(			CU_clk, PORT_service[0], SW, 							PORT_deviceData[0], PORT_DE[0], PORT_DRW[0]);
	keyboard_input PORT_KEY(		CU_clk, PORT_service[1], KEY, 						PORT_deviceData[1], PORT_DE[1], PORT_DRW[1]);
	hex_output 		PORT_HEX(		CU_clk, PORT_service[2], HEX0, HEX1, HEX2, HEX3,PORT_deviceData[2], PORT_DE[2], PORT_DRW[2]);
	ps2Keyboard		PORT_KYB(
		.PS2_CLK(PS2_CLK),
		.PS2_DAT(PS2_DAT),
		.PS2_CLK2(PS2_CLK2),
		.PS2_DAT2(PS2_DAT2),
			
		.CLOCK_50(CLOCK_50),
		.DRW(PORT_DRW[3]),
		.DE(PORT_DE[3]),
		.port_data(PORT_deviceData[3]),
		.port_service(PORT_service[3])
	);
	led_output 		PORT_LED(		CU_clk, PORT_service[4], LEDR, 						PORT_deviceData[4], PORT_DE[4], PORT_DRW[4]);
	
	sinCosPort cordic(
		.clk(CU_clk),
		
		.service_input(PORT_service[16]),
		.service_sin(PORT_service[17]),
		.service_cos(PORT_service[18]),
		
		.data_input(PORT_deviceData2[0]),
		.data_sin(PORT_deviceData2[1]),
		.data_cos(PORT_deviceData2[2]),
		
		.de_input(PORT_DE[16]),
		.de_sin(PORT_DE[17]),
		.de_cos(PORT_DE[18]),
		
		.drw_input(PORT_DRW[16]),
		.drw_sin(PORT_DRW[17]),
		.drw_cos(PORT_DRW[18]),
	);
	
	
	//=======================================================
	// ALU
	//=======================================================
	
	wire[15:0] ALU_a, ALU_b, ALU_z;
	wire[3:0] ALU_opcode;
	wire ALU_cin, ALU_cout, ALU_zero, ALU_sign, ALU_we, ALU_oe, ALU_loadState;
	
	wire ALU_clk;
	
	ALU(
		.clk(CU_clk),
		.we(ALU_we),
		.oe(ALU_oe),
		.setState(ALU_loadState),
		.newState(BUS[2:0]),
		
		.opcode(ALU_opcode),
		.cin(ALU_cin),
		.a(ALU_a),
		.b(ALU_b),
		.z_out(ALU_z),
		
		.cout(ALU_cout),
		.zero(ALU_zero),
		.sign(ALU_sign)
	);
	//ALU(CU_clk, ALU_we, ALU_oe, ALU_cin, ALU_a, ALU_b, ALU_opcode, ALU_z, ALU_cout, ALU_zero, ALU_sign);
	
	//=======================================================
	// Registers
	//=======================================================
	
	wire[15:0] REG_dstData, REG_srcData, REG_setData;
	wire[3:0] REG_dst, REG_src;
	wire REG_clk, REG_oe, REG_we, REG_inc, REG_dec;
	regFile #(16,16) REG(CU_clk, REG_oe, REG_we, REG_inc, REG_dec, REG_dst, REG_src, REG_setData, REG_dstData, REG_srcData);
	
	//=======================================================
	// Memory
	//=======================================================
	
	wire[31:0] PM_q;
	wire[15:0] PM_address, DM_data, DM_q;
	wire[31:0] DM_address;
	wire PM_clk, PM_ae, DM_clock, DM_we, DM_ade, DM_oe, DM_adx, DM_readDone;
	
	programMemory PM(PM_address, CU_clk, PM_ae, PM_q);
	//dataMemory DM(DM_address, DM_data, CU_clk, DM_ade, DM_we, DM_q);
	
	internalMemory #(0) DM(
		.clk(CU_clk),
		.writeEn(DM_we),
		.outputEn(DM_oe),
		.addressDataEn(DM_ade),
		.address(DM_address),
		.data(BUS),
		.readDone(DM_readDone)
	);
	
	VGA_memoryMap display(
		.CLOCK_50(CLOCK_50),
		.data(BUS),
		.address(DM_address),
		.addressDataEn(DM_ade),
		.writeEn(DM_we),
		.outputEn(DM_oe),
		.readDone(DM_readDone),
	
		.VGA_R(VGA_R),
		.VGA_G(VGA_G),
		.VGA_B(VGA_B),
		.VGA_CLK(VGA_CLK),
		.VGA_BLANK(VGA_BLANK_N),
		.VGA_HS(VGA_HS),
		.VGA_VS(VGA_VS),
		.VGA_SYNC(VGA_SYNC_N)
	);
	
	
	keyCodeDecoder_memoryMap #('h92C0) toAscii(
		.CLOCK_50(CLOCK_50),
		.BUS(BUS),
		.address(DM_address),
		.writeEn(DM_we),
		.outputEn(DM_oe),
		.readDone(DM_readDone)
	);
	
	multiply_memoryMap #('h92C2) mcp1(
		.CLOCK_50(CLOCK_50),
		.BUS(BUS),
		.address(DM_address),
		.writeEn(DM_we),
		.outputEn(DM_oe),
		.readDone(DM_readDone)
	);
	
	divide_memoryMap #('h92C5) mcp2(
		.CLOCK_50(CLOCK_50),
		.BUS(BUS),
		.address(DM_address),
		.writeEn(DM_we),
		.outputEn(DM_oe),
		.readDone(DM_readDone)
	);
	
	vector_memoryMap #('h92C9) mcp3(
		.CLOCK_50(CLOCK_50),
		.BUS(BUS),
		.address(DM_address),
		.writeEn(DM_we),
		.outputEn(DM_oe),
		.readDone(DM_readDone)
	);
	
	lfsr_memoryMap #('h92D3) mcp4(
		.CLOCK_50(CLOCK_50),
		.BUS(BUS),
		.address(DM_address),
		.writeEn(DM_we),
		.outputEn(DM_oe),
		.readDone(DM_readDone)
	);
	
	//=======================================================
	// Control
	//=======================================================
	
	wire[15:0] immediate;
	
	
	assign CU_clk =  CU_debugEnable? CU_debugClock:CLOCK_50;
	wire CU_debugClock;
	edgeDetect step(KEY[0], CLOCK_50, CU_debugClock);
	
	assign BUS = PORT_hostData;
	assign BUS = ALU_z;
	assign BUS = REG_srcData;
	
	assign REG_setData = BUS;
	
	assign DM_address = {(DM_adx? DM_offset:16'b0) ,(CU_ie_address? immediate:REG_dstData)};
	
	assign ALU_a = REG_dstData;
	assign ALU_b = BUS;
	
	ControlUnit CU(
	.instruction	(PM_q),
	.imm				(immediate),
	.cr2				(DM_offset),
	.CU_debugEnable(CU_debugEnable),
	.CU_ie			(CU_ie),
	.CU_ie_address (CU_ie_address),
	.PM_ae			(PM_ae),
	.PM_addr			(PM_address),
	.bus				(BUS),
	.clk				(CU_clk),
	
	.ALU_zero		(ALU_zero),
	.ALU_sign		(ALU_sign),
	.ALU_cout		(ALU_cout),
	.ALU_we			(ALU_we),
	.ALU_oe			(ALU_oe),
	.ALU_opcode		(ALU_opcode),
	
	.PORT_service	(PORT_service),
	.PORT_select	(PORT_select),
	.PORT_he			(PORT_HE),
	.PORT_hrw		(PORT_HRW),
	
	.RF_dst			(REG_dst),
	.RF_src			(REG_src),
	.RF_we			(REG_we),
	.RF_oe			(REG_oe),
	.RF_inc			(REG_inc),
	.RF_dec			(REG_dec),
	
	.DM_we			(DM_we),
	.DM_ade			(DM_ade),
	.DM_oe			(DM_oe),
	.DM_adx			(DM_adx),
	//.DM_readDone	(DM_readDone)
	);
endmodule

